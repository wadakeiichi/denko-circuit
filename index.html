 <!DOCTYPE html>
  <html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>複線図シミュレータ</title>
    <style>
      :root { color-scheme: light; }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #f4f6f8;
        color: #1f2933;
      }
      .app { display: flex; min-height: 100vh; }
      .sidebar {
        width: 320px;
        padding: 24px;
        background: #ffffff;
        border-right: 1px solid #d0d7de;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }
      .sidebar h1 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
      }
      .panel h2 {
        margin: 0 0 8px 0;
        font-size: 15px;
        font-weight: 600;
      }
      .panel p, .panel li {
        margin: 0;
        font-size: 14px;
        line-height: 1.5;
      }
      .panel ul { padding-left: 20px; }
      .panel li { margin-bottom: 6px; }
      .color-selector {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 12px;
      }
      .selector-label {
        margin: 12px 0 0 0;
        font-size: 12px;
        font-weight: 600;
        color: #475569;
      }
      .gauge-selector {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .color-button, .gauge-button, .tool-button {
        border: 1px solid #d0d7de;
        background: #f8fafc;
        padding: 10px 12px;
        border-radius: 6px;
        font-size: 14px;
        text-align: left;
        cursor: pointer;
        transition: all .15s ease;
      }
      .color-button:hover, .gauge-button:hover, .tool-button:hover { border-color: #94a3b8; background: #f1f5f9; }
      .color-button.active, .gauge-button.active, .tool-button.active {
        border-color: #2563eb;
        background: #dbeafe;
        color: #1d4ed8;
        box-shadow: 0 0 0 1px #2563eb inset;
      }
      .gauge-button {
        text-align: center;
      }
      .color-button {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .color-button::before {
        content: '';
        display: inline-block;
        width: 16px;
        height: 16px;
        border-radius: 4px;
        border: 1px solid #1e293b;
      }
      .color-button[data-color="black"]::before { background: #111827; border-color: #0f172a; }
      .color-button[data-color="blue"]::before { background: #1d4ed8; border-color: #1e3a8a; }
      .color-button[data-color="red"]::before { background: #dc2626; border-color: #991b1b; }
      .tool-buttons {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .component-palette {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 8px;
      }
      .component-button {
        border: 1px solid #d0d7de;
        background: #ffffff;
        padding: 10px;
        border-radius: 6px;
        font-size: 13px;
        text-align: center;
        cursor: pointer;
        transition: all .15s ease;
      }
      .component-button:hover { border-color: #94a3b8; background: #f8fafc; }
      .component-button.active {
        border-color: #f97316;
        background: #fff7ed;
        color: #c2410c;
        box-shadow: 0 0 0 1px #f97316 inset;
      }
      .main { flex: 1; display: flex; flex-direction: column; }
      .canvas-header {
        padding: 18px 24px;
        background: #ffffff;
        border-bottom: 1px solid #d0d7de;
        font-size: 14px;
        display: flex;
        justify-content: flex-start;
        align-items: stretch;
        gap: 16px;
        flex-wrap: wrap;
        height: 128px;
      }
      .canvas-stage { flex: 1; position: relative; min-height: 640px; }
      canvas { width: 100%; height: 100%; display: block; cursor: crosshair; }
      .status {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        font-size: 13px;
        color: #475569;
        flex-wrap: wrap;
        width: 100%;
      }
      .status > span,
      .status > button {
        flex: 0 0 auto;
      }
      #status-tip {
        flex: 1 1 100%;
        min-height: 24px;
        display: block;
        padding-top: 4px;
      }
      .sleeve-menu, .wire-menu {
        position: absolute;
        background: #ffffff;
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        box-shadow: 0 12px 24px rgb(15 23 42 / 0.16);
        padding: 8px;
        display: none;
        z-index: 1000;
        min-width: 160px;
      }
      .sleeve-menu.open { display: block; }
      .wire-menu.open { display: block; }
      .sleeve-menu button, .wire-menu button {
        width: 100%;
        border: none;
        background: transparent;
        padding: 6px 8px;
        text-align: left;
        font-size: 13px;
        border-radius: 4px;
        cursor: pointer;
      }
      .sleeve-menu button:hover,
      .wire-menu button:hover {
        background: #e2e8f0;
      }
      .status span { display: flex; align-items: center; gap: 4px; }
      .check-button {
        border: 1px solid #d0d7de;
        background: #ffffff;
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 13px;
        cursor: pointer;
        transition: all .15s ease;
      }
      .check-button:hover { border-color: #94a3b8; background: #f8fafc; }
      .switch-toggle {
        border: 1px solid #d0d7de;
        background: #f8fafc;
        padding: 4px 10px;
        border-radius: 4px;
        font-size: 13px;
        cursor: pointer;
        transition: all .15s ease;
      }
      .switch-toggle:hover { border-color: #94a3b8; background: #f1f5f9; }
      .switch-toggle.on {
        border-color: #22c55e;
        background: #dcfce7;
        color: #166534;
        box-shadow: 0 0 0 1px #22c55e inset;
      }
      .switch-toggle:disabled {
        opacity: .5;
        cursor: not-allowed;
      }
      .lamp-indicator.on { color: #d97706; }
      .outlet-indicator { transition: color .2s ease; }
      .outlet-indicator.on { color: #15803d; }
      .outlet-indicator.partial { color: #b45309; }
      .sleeve-selector {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 8px;
      }
      .sleeve-buttons {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .sleeve-info {
        font-size: 12px;
        color: #475569;
        margin: 4px 0 0 0;
        padding-left: 12px;
      }
      .pairing-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .pairing-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-size: 13px;
      }
      .pairing-item label {
        flex: 1;
      }
      .pairing-select {
        min-width: 88px;
        padding: 4px 6px;
        border: 1px solid #cbd5e1;
        border-radius: 4px;
        font-size: 13px;
        background: #ffffff;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <aside class="sidebar">
        <div class="panel">
          <h1>複線図シミュレータ</h1>
          <p>電源 (1Φ2W 100V)、単極スイッチ、コンセント（接地側Wマーク）、ランプを結線し、複線図を作図できます。
  </p>
        </div>
        <div class="panel">
          <h2>芯線設定</h2>
          <p class="selector-label">色</p>
          <div id="color-selector" class="color-selector"></div>
          <p class="selector-label">太さ</p>
          <div id="gauge-selector" class="gauge-selector"></div>
        </div>
        <div class="panel">
          <h2>ツール</h2>
          <div id="tool-buttons" class="tool-buttons"></div>
        </div>
        <div class="panel">
          <h2>器具パレット</h2>
          <div id="component-palette" class="component-palette"></div>
        </div>
        <div class="panel">
          <h2>対応マーク</h2>
          <div id="pairing-assignments" class="pairing-list"></div>
        </div>
        <div class="panel">
          <h2>操作方法</h2>
          <ul>
            <li>配線モード: コネクタをダブルクリックして配線開始、終点をクリックで接続。背景クリックで折り点を追加</li>
            <li>器具パレットから選択し、キャンバスをクリックすると配置できます</li>
            <li>ヘッダーの「配線チェック」ボタンで芯線色の整合性を確認できます</li>
            <li>配線前に芯線色を選択すると、その接続区間の色になります</li>
            <li>スイッチ操作: ヘッダーのボタンで入/切を切り替えて動作を確認</li>
            <li>消しゴムモード: 配線や器具をクリックして削除</li>
            <li>既存ケーブルをダブルクリックで分岐用接続点（J）を挿入</li>
            <li>接続点挿入時は、接続点から先の区間が現在選択中の色で再作成されます</li>
            <li>接続点はドラッグして位置を調整できます</li>
            <li>機器の外枠をドラッグして配置を移動</li>
            <li>刻印モード: ツールバー「刻印」を選択し、接続点をクリックでスリーブ刻印を設定</li>
            <li>Ctrl + クリックで接続点のスリーブ刻印や配線の色/太さをメニューから変更可能</li>
            <li>Escキーで作図中の配線や器具選択をキャンセル</li>
          </ul>
        </div>
      </aside>
      <main class="main">
        <div class="canvas-header">
          <div class="status">
            <span>選択中の芯線色: <strong id="selected-color-label"></strong></span>
            <span>芯線太さ: <strong id="selected-gauge-label"></strong></span>
            <span>スイッチ:
              <button id="switch-toggle" type="button" class="switch-toggle">切 (OFF)</button>
            </span>
            <span>ランプ: <strong id="lamp-status" class="lamp-indicator">消灯</strong></span>
            <span>コンセント: <strong id="outlet-status" class="outlet-indicator">未配置</strong></span>
            <button id="undo-button" type="button" class="check-button" disabled>戻る</button>
            <button id="check-wiring" type="button" class="check-button">配線チェック</button>
            <button id="check-sleeves" type="button" class="check-button">スリーブチェック</button>
            <span id="status-tip"></span>
          </div>
        </div>
        <div class="canvas-stage">
          <canvas id="wiring-canvas"></canvas>
        </div>
      </main>
    </div>
    <div id="sleeve-menu" class="sleeve-menu" role="menu" aria-hidden="true"></div>
    <div id="wire-menu" class="wire-menu" role="menu" aria-hidden="true"></div>

    <script>
      (() => {
        const conductorOptions = [
          { id: 'black', label: '黒', color: 'black' },
          { id: 'blue', label: '青', color: 'blue' },
          { id: 'red', label: '赤', color: 'red' }
        ];
        const conductorGaugeOptions = [
          { id: '1_6', label: '1.6mm', value: '1.6' },
          { id: '2_0', label: '2.0mm', value: '2.0' }
        ];
        const sleeveOptions = [
          { id: 'round', label: '◯スリーブ', mark: '◯' },
          { id: 'small', label: '小スリーブ', mark: '小' },
          { id: 'medium', label: '中スリーブ', mark: '中' }
        ];
        const wireColorGaugeOptions = [
          { id: 'black_1_6', label: '黒 1.6mm', color: 'black', gauge: '1.6' },
          { id: 'black_2_0', label: '黒 2.0mm', color: 'black', gauge: '2.0' },
          { id: 'blue_1_6', label: '青 1.6mm', color: 'blue', gauge: '1.6' },
          { id: 'blue_2_0', label: '青 2.0mm', color: 'blue', gauge: '2.0' },
          { id: 'red_1_6', label: '赤 1.6mm', color: 'red', gauge: '1.6' },
          { id: 'red_2_0', label: '赤 2.0mm', color: 'red', gauge: '2.0' }
        ];

        const pairingKana = ['イ', 'ロ', 'ハ', 'ニ', 'ホ', 'ヘ', 'ト', 'チ', 'リ', 'ヌ', 'ル', 'ヲ', 'ワ', 'カ', 'ヨ', 'タ', 'レ', 'ソ', 'ツ', 'ネ', 'ナ', 'ラ', 'ム', 'ウ', 'ヰ', 'ノ', 'オ', 'ク', 'ヤ', 'マ', 'ケ', 'フ', 'コ', 'エ', 'テ', 'ア', 'サ', 'キ', 'ユ', 'メ', 'ミ', 'シ', 'ヱ', 'ヒ', 'モ', 'セ', 'ス'];
        const pairingOptions = pairingKana.slice(0, 10);

        const toolModes = [
          { id: 'draw', label: '配線' },
          { id: 'erase', label: '消しゴム' },
          { id: 'mark', label: '刻印' }
        ];

        const componentTemplates = {
          power: {
            type: 'power',
            displayName: '電源',
            label: '電源\n1Φ2W 100V',
            size: { width: 164, height: 120 },
            defaultPosition: { x: 80, y: 200 },
            connectors: [
              { key: 'hot', label: 'L', color: 'black', role: 'hot', offset: { x: 164, y: 40 } },
              { key: 'neutral', label: 'N', color: 'blue', role: 'neutral', offset: { x: 164, y: 80 } }
            ]
          },
          switch: {
            type: 'switch',
            displayName: '単極スイッチ',
            label: '単極スイッチ',
            size: { width: 110, height: 100 },
            defaultPosition: { x: 340, y: 210 },
            connectors: [
              { key: 'in', label: 'IN', color: 'black', role: 'hot', offset: { x: 0, y: 50 } },
              { key: 'out', label: 'OUT', color: 'black', role: 'switched', offset: { x: 110, y: 50 } }
            ]
          },
          outlet: {
            type: 'outlet',
            displayName: 'コンセント',
            label: 'コンセント',
            size: { width: 140, height: 160 },
            defaultPosition: { x: 570, y: 190 },
            connectors: [
              { key: 'neutral', label: 'W', color: 'blue', role: 'neutral', offset: { x: 0, y: 80 } },
              { key: 'hot', label: 'L', color: 'black', role: 'hot', offset: { x: 140, y: 80 } }
            ]
          },
          lamp: {
            type: 'lamp',
            displayName: 'ランプレセプタクル',
            label: 'ランプレセプタクル',
            size: { width: 170, height: 170 },
            defaultPosition: { x: 860, y: 160 },
            connectors: [
              { key: 'neutral', label: 'N', color: 'blue', role: 'neutral', offset: { x: 0, y: 85 } },
              { key: 'hot', label: 'L', color: 'black', role: 'switched', offset: { x: 170, y: 85 } }
            ]
          },
          pilot: {
            type: 'pilot',
            displayName: 'パイロットランプ',
            label: 'パイロットランプ',
            size: { width: 120, height: 120 },
            defaultPosition: { x: 1040, y: 320 },
            connectors: [
              { key: 'neutral', label: 'N', color: 'blue', role: 'neutral', offset: { x: 0, y: 60 } },
              { key: 'hot', label: 'L', color: 'black', role: 'switched', offset: { x: 120, y: 60 } }
            ]
          }
        };

        const rotatableComponentTypes = new Set(['switch', 'outlet', 'lamp', 'pilot']);

        const initialComponentLayout = [
          { type: 'power' },
          { type: 'switch' },
          { type: 'outlet' },
          { type: 'lamp' }
        ];

        const state = {
          selectedColor: conductorOptions[0].color,
          selectedGauge: conductorGaugeOptions[0].value,
          selectedSleeveType: sleeveOptions[0].id,
          toolMode: 'draw',
          components: [],
          wires: [],
          junctions: [],
          activeWire: null,
          hoverConnectorId: null,
          hoverWireId: null,
          pointer: null,
          draggingComponent: null,
          draggingJunction: null,
          statusResetTimer: null,
          switchClosed: false,
          lampOn: false,
          pilotOn: false,
          outletStatuses: new Map(),
          pendingComponentType: null,
          primaryIds: { power: null, switch: null, lamp: null },
          pairingLabels: new Map(),
          pairingAssignments: new Map(),
          counters: {
            wire: 0,
            junction: 0,
            component: { power: 0, switch: 0, outlet: 0, lamp: 0, pilot: 0 }
          },
          sleeveMenu: { isOpen: false, junctionId: null },
          wireMenu: { isOpen: false, wireId: null },
          showSleeveMarks: false
        };

        const history = [];
        const historyLimit = 50;
        let historySuspended = false;

        let componentConnectorIndex = new Map();
        state.junctionIndex = new Map();

        const canvas = document.getElementById('wiring-canvas');
        const ctx = canvas.getContext('2d');
        const colorSelectorContainer = document.getElementById('color-selector');
        const gaugeSelectorContainer = document.getElementById('gauge-selector');
        const sleeveButtonsContainer = document.getElementById('sleeve-buttons');
        const componentPaletteContainer = document.getElementById('component-palette');
        const selectedColorLabel = document.getElementById('selected-color-label');
        const selectedGaugeLabel = document.getElementById('selected-gauge-label');
        const switchToggle = document.getElementById('switch-toggle');
        const lampStatusLabel = document.getElementById('lamp-status');
        const outletStatusLabel = document.getElementById('outlet-status');
        const undoButton = document.getElementById('undo-button');
        const pairingAssignmentsContainer = document.getElementById('pairing-assignments');
        const checkWiringButton = document.getElementById('check-wiring');
        const checkSleevesButton = document.getElementById('check-sleeves');
        const statusTip = document.getElementById('status-tip');
        const toolButtonsContainer = document.getElementById('tool-buttons');
        const sleeveMenu = document.getElementById('sleeve-menu');
        const wireMenu = document.getElementById('wire-menu');

        function init() {
          buildColorControls();
          buildGaugeControls();
          buildSleeveControls();
          buildComponentPalette();
          buildToolButtons();
          seedInitialComponents();
          buildPairingControls();
          syncPairingLabels();
          rebuildConnectorIndex();
          bindEvents();
          if (switchToggle) {
            switchToggle.addEventListener('click', toggleSwitch);
          }
          if (checkWiringButton) {
            checkWiringButton.addEventListener('click', () => {
              const { errors, warnings } = validateConductorAssignments();
              if (errors.length) {
                updateStatusTip(errors[0]);
              } else if (warnings.length) {
                updateStatusTip(warnings[0]);
              } else {
                updateStatusTip('配線に問題は見つかりませんでした');
              }
            });
          }
          if (checkSleevesButton) {
            checkSleevesButton.addEventListener('click', () => {
              const { errors, warnings } = validateSleeves();
              if (errors.length) {
                updateStatusTip(errors[0]);
              } else if (warnings.length) {
                updateStatusTip(warnings[0]);
              } else {
                updateStatusTip('スリーブに問題は見つかりませんでした');
              }
              state.showSleeveMarks = true;
              draw();
            });
          }
          if (undoButton) {
            undoButton.addEventListener('click', undoLastAction);
          }
          window.addEventListener('click', evt => {
            if (!state.sleeveMenu.isOpen) return;
            if (sleeveMenu && sleeveMenu.contains(evt.target)) return;
            if (evt.ctrlKey) return;
            closeSleeveMenu();
          });
          window.addEventListener('click', evt => {
            if (!state.wireMenu.isOpen) return;
            if (wireMenu && wireMenu.contains(evt.target)) return;
            if (evt.ctrlKey) return;
            closeWireMenu();
          });
          window.addEventListener('keydown', evt => {
            if (evt.key === 'Escape') {
              closeSleeveMenu();
              closeWireMenu();
            }
          });
          updateUndoUI();
          updateSwitchUI();
          updateGaugeUI();
          updateSleeveUI();
          updateLampStatusUI();
          window.requestAnimationFrame(resizeCanvas);
          updateStatusTip();
        }

        function buildColorControls() {
          if (!colorSelectorContainer) return;
          colorSelectorContainer.innerHTML = '';
          conductorOptions.forEach(option => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'color-button';
            button.dataset.color = option.color;
            button.textContent = option.label;
            button.addEventListener('click', () => {
              state.selectedColor = option.color;
              updateColorUI();
              if (state.toolMode !== 'draw') {
                setToolMode('draw');
              }
            });
            colorSelectorContainer.appendChild(button);
          });
          updateColorUI();
        }

        function buildGaugeControls() {
          if (!gaugeSelectorContainer) return;
          gaugeSelectorContainer.innerHTML = '';
          conductorGaugeOptions.forEach(option => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'gauge-button';
            button.dataset.gauge = option.value;
            button.textContent = option.label;
            button.addEventListener('click', () => {
              if (state.selectedGauge === option.value) return;
              recordHistory();
              state.selectedGauge = option.value;
              updateGaugeUI();
              if (state.toolMode !== 'draw') {
                setToolMode('draw');
              }
              updateStatusTip('芯線太さを' + option.label + 'に設定しました');
            });
            gaugeSelectorContainer.appendChild(button);
          });
          updateGaugeUI();
        }

        function buildSleeveControls() {
          if (!sleeveButtonsContainer) return;
          sleeveButtonsContainer.innerHTML = '';
          sleeveOptions.forEach(option => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'gauge-button';
            button.dataset.sleeve = option.id;
            button.textContent = option.mark + ' ' + option.label;
            button.addEventListener('click', () => {
              if (state.selectedSleeveType === option.id) return;
              state.selectedSleeveType = option.id;
              updateSleeveUI();
              if (state.toolMode !== 'draw') {
                setToolMode('draw');
              }
              updateStatusTip(option.label + 'を選択しました。刻印モードで接続点をクリックしてください');
            });
            sleeveButtonsContainer.appendChild(button);
          });
          updateSleeveUI();
        }

        function buildComponentPalette() {
          if (!componentPaletteContainer) return;
          componentPaletteContainer.innerHTML = '';
          Object.values(componentTemplates).forEach(template => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'component-button';
            button.dataset.componentType = template.type;
            button.textContent = template.displayName;
            button.addEventListener('click', () => setPendingComponentType(template.type));
            componentPaletteContainer.appendChild(button);
          });
          updateComponentPaletteUI();
        }

        function buildPairingControls() {
          if (!pairingAssignmentsContainer) return;
          pairingAssignmentsContainer.innerHTML = '';
          const targets = state.components.filter(isPairingComponent);
          if (!targets.length) {
            const message = document.createElement('div');
            message.textContent = '対象器具がありません';
            message.style.fontSize = '13px';
            message.style.color = '#64748b';
            pairingAssignmentsContainer.appendChild(message);
            return;
          }
          targets.forEach(component => {
            if (!state.pairingAssignments.has(component.id)) {
              state.pairingAssignments.set(component.id, null);
            }
            const item = document.createElement('div');
            item.className = 'pairing-item';
            const label = document.createElement('label');
            label.textContent = componentLabel(component);
            label.setAttribute('for', component.id + '-pairing-select');
            const select = document.createElement('select');
            select.id = component.id + '-pairing-select';
            select.className = 'pairing-select';
            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '未設定';
            select.appendChild(emptyOption);
            pairingOptions.forEach(optionLabel => {
              const option = document.createElement('option');
              option.value = optionLabel;
              option.textContent = optionLabel;
              select.appendChild(option);
            });
            const current = state.pairingAssignments.get(component.id);
            select.value = current || '';
            select.addEventListener('change', () => {
              const value = select.value || null;
              handlePairingSelection(component.id, value);
            });
            item.appendChild(label);
            item.appendChild(select);
            pairingAssignmentsContainer.appendChild(item);
          });
        }

        function componentLabel(component) {
          const template = componentTemplates[component.type];
          const base = template ? template.displayName : component.label;
          return base + ' (' + component.id + ')';
        }

        function isPairingComponent(component) {
          return component.type === 'switch' || component.type === 'lamp' || component.type === 'pilot';
        }

        function handlePairingSelection(componentId, label) {
          recordHistory();
          state.pairingAssignments.set(componentId, label);
          syncPairingLabels();
          draw();
        }

        function syncPairingLabels() {
          state.pairingLabels = new Map();
          state.pairingAssignments.forEach((label, componentId) => {
            if (label) {
              state.pairingLabels.set(componentId, label);
            }
          });
        }

        function getPairingDisplayLabel(componentId) {
          if (!state.pairingAssignments.has(componentId)) return null;
          const label = state.pairingAssignments.get(componentId);
          if (label) return label;
          const auto = state.pairingLabels.get(componentId);
          if (auto) return auto;
          return 'ー';
        }

        function getSleeveOptionById(id) {
          return sleeveOptions.find(option => option.id === id) || sleeveOptions[0];
        }

        function captureSnapshot() {
          return {
            selectedColor: state.selectedColor,
            selectedGauge: state.selectedGauge,
            selectedSleeveType: state.selectedSleeveType,
            toolMode: state.toolMode,
            components: state.components.map(component => ({
              id: component.id,
              type: component.type,
              label: component.label,
              position: { x: component.position.x, y: component.position.y },
              size: { width: component.size.width, height: component.size.height },
              connectors: component.connectors.map(connector => ({
                id: connector.id,
                key: connector.key,
                label: connector.label,
                color: connector.color,
                role: connector.role,
                offset: { x: connector.offset.x, y: connector.offset.y }
              }))
            })),
            wires: state.wires.map(wire => ({
              id: wire.id,
              color: wire.color,
              gauge: wire.gauge || conductorGaugeOptions[0].value,
              points: wire.points.map(point => ({ x: point.x, y: point.y })),
              startConnectorId: wire.startConnectorId,
              endConnectorId: wire.endConnectorId
            })),
            junctions: state.junctions.map(junction => ({
              id: junction.id,
              label: junction.label,
              x: junction.x,
              y: junction.y,
              sleeveType: junction.sleeveType || sleeveOptions[0].id
            })),
            switchClosed: state.switchClosed,
            pendingComponentType: state.pendingComponentType,
            primaryIds: { ...state.primaryIds },
            pairingAssignments: Array.from(state.pairingAssignments.entries()),
            counters: JSON.parse(JSON.stringify(state.counters))
          };
        }

        function restoreSnapshot(snapshot) {
          historySuspended = true;
          state.selectedColor = snapshot.selectedColor;
          state.selectedGauge = snapshot.selectedGauge || conductorGaugeOptions[0].value;
          state.selectedSleeveType = snapshot.selectedSleeveType || sleeveOptions[0].id;
          state.toolMode = snapshot.toolMode || 'draw';
          state.components = snapshot.components.map(component => {
            const template = componentTemplates[component.type];
            const baseSize = component.baseSize
              ? { width: component.baseSize.width, height: component.baseSize.height }
              : template
                ? { width: template.size.width, height: template.size.height }
                : { width: component.size.width, height: component.size.height };
            const rotation = normalizeRotation(typeof component.rotation === 'number' ? component.rotation : 0);
            const size = component.size
              ? { width: component.size.width, height: component.size.height }
              : getRotatedSize(baseSize, rotation);
            return {
              id: component.id,
              type: component.type,
              label: component.label,
              position: { x: component.position.x, y: component.position.y },
              size,
              baseSize,
              rotation,
              connectors: component.connectors.map(connector => ({
                id: connector.id,
                key: connector.key,
                label: connector.label,
                color: connector.color,
                role: connector.role,
                offset: { x: connector.offset.x, y: connector.offset.y }
              }))
            };
          });
          state.wires = snapshot.wires.map(wire => ({
            id: wire.id,
            color: wire.color,
            gauge: wire.gauge || conductorGaugeOptions[0].value,
            points: wire.points.map(point => ({ x: point.x, y: point.y })),
            startConnectorId: wire.startConnectorId,
            endConnectorId: wire.endConnectorId
          }));
          state.junctions = snapshot.junctions.map(junction => ({
            id: junction.id,
            label: junction.label,
            x: junction.x,
            y: junction.y,
            sleeveType: junction.sleeveType || sleeveOptions[0].id
          }));
          state.junctionIndex = new Map();
          state.junctions.forEach(junction => {
            state.junctionIndex.set(junction.id, junction);
          });
          state.switchClosed = Boolean(snapshot.switchClosed);
          state.pendingComponentType = snapshot.pendingComponentType || null;
          state.primaryIds = { ...snapshot.primaryIds };
          state.pairingAssignments = new Map(snapshot.pairingAssignments || []);
          state.pairingLabels = new Map();
          state.counters = JSON.parse(JSON.stringify(snapshot.counters));
          state.activeWire = null;
          state.hoverConnectorId = null;
          state.hoverWireId = null;
          state.pointer = null;
          state.draggingComponent = null;
          state.draggingJunction = null;
          state.outletStatuses = new Map();
          state.lampOn = false;
          state.pilotOn = false;
          state.showSleeveMarks = false;
          closeSleeveMenu();
          closeWireMenu();
          historySuspended = false;
          rebuildConnectorIndex();
          buildPairingControls();
          syncPairingLabels();
          updateColorUI();
          updateGaugeUI();
          updateComponentPaletteUI();
          updateToolButtons();
          updateSwitchUI();
          updateStatusTip();
          draw();
        }

        function recordHistory() {
          if (historySuspended) return;
          history.push(captureSnapshot());
          if (history.length > historyLimit) {
            history.shift();
          }
          updateUndoUI();
        }

        function undoLastAction() {
          if (!history.length) return;
          const snapshot = history.pop();
          restoreSnapshot(snapshot);
          updateUndoUI();
          updateStatusTip('直前の操作を取り消しました');
        }

        function updateUndoUI() {
          if (!undoButton) return;
          undoButton.disabled = history.length === 0;
        }

        function setPendingComponentType(type) {
          if (state.pendingComponentType === type) {
            state.pendingComponentType = null;
            updateStatusTip('器具の選択を取消しました');
          } else {
            state.pendingComponentType = type;
            if (state.toolMode === 'erase') {
              setToolMode('draw');
            }
            const template = componentTemplates[type];
            if (template) {
              updateStatusTip(template.displayName + 'を配置する位置をクリック');
            }
          }
          updateComponentPaletteUI();
        }

        function updateComponentPaletteUI() {
          if (!componentPaletteContainer) return;
          componentPaletteContainer.querySelectorAll('.component-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.componentType === state.pendingComponentType);
          });
        }

        function seedInitialComponents() {
          if (state.components.length) return;
          historySuspended = true;
          initialComponentLayout.forEach(entry => {
            addComponentInstance(entry.type, entry.position || null);
          });
          historySuspended = false;
        }

        function addComponentInstance(type, position = null) {
          const component = createComponentInstance(type, position);
          if (!component) return null;
          recordHistory();
          state.components.push(component);
          if (isPairingComponent(component)) {
            state.pairingAssignments.set(component.id, null);
          }
          buildPairingControls();
          syncPairingLabels();
          if (Object.prototype.hasOwnProperty.call(state.primaryIds, component.type) &&
            !state.primaryIds[component.type]) {
            state.primaryIds[component.type] = component.id;
          }
          rebuildConnectorIndex();
          updateSwitchUI();
          return component;
        }

        function placePendingComponent(point) {
          const type = state.pendingComponentType;
          const template = type ? componentTemplates[type] : null;
          if (!template) return false;
          const rect = canvas.getBoundingClientRect();
          const stageWidth = rect.width || (template.size.width + 40);
          const stageHeight = rect.height || (template.size.height + 40);
          const margin = 12;
          const maxX = stageWidth - template.size.width - margin;
          const maxY = stageHeight - template.size.height - margin;
          const position = {
            x: Math.max(margin, Math.min(point.x - template.size.width / 2, maxX)),
            y: Math.max(margin, Math.min(point.y - template.size.height / 2, maxY))
          };
          const component = addComponentInstance(type, position);
          if (!component) return false;
          state.pendingComponentType = null;
          updateComponentPaletteUI();
          updateStatusTip(template.displayName + 'を配置しました');
          draw();
          return true;
        }

        function createComponentInstance(type, position = null) {
          const template = componentTemplates[type];
          if (!template) return null;
          if (!Object.prototype.hasOwnProperty.call(state.counters.component, type)) {
            state.counters.component[type] = 0;
          }
          state.counters.component[type] += 1;
          const id = type + '-' + state.counters.component[type];
          const basePosition = position || template.defaultPosition || { x: 120, y: 120 };
          const baseSize = { width: template.size.width, height: template.size.height };
          const rotation = 0;
          const component = {
            id,
            type: template.type,
            label: template.label,
            position: { x: basePosition.x, y: basePosition.y },
            size: getRotatedSize(baseSize, rotation),
            baseSize,
            rotation,
            connectors: template.connectors.map(connector => ({
              key: connector.key,
              label: connector.label,
              color: connector.color,
              role: connector.role,
              offset: { x: connector.offset.x, y: connector.offset.y },
              id: id + '-' + connector.key
            }))
          };
          return component;
        }

        function isRotatableType(type) {
          return rotatableComponentTypes.has(type);
        }

        function canRotateComponent(component) {
          return Boolean(component && isRotatableType(component.type));
        }

        function rotateComponentInstance(component, step = 90) {
          if (!canRotateComponent(component)) return;
          const baseSize = component.baseSize || component.size;
          const center = getComponentCenter(component);
          const nextRotation = normalizeRotation((component.rotation || 0) + step);
          const newSize = getRotatedSize(baseSize, nextRotation);
          component.rotation = nextRotation;
          component.size.width = newSize.width;
          component.size.height = newSize.height;
          component.position.x = center.x - newSize.width / 2;
          component.position.y = center.y - newSize.height / 2;
        }

        function rebuildConnectorIndex() {
          componentConnectorIndex = new Map();
          state.components.forEach(component => {
            component.connectors.forEach(connector => {
              componentConnectorIndex.set(connector.id, { component, connector });
            });
          });
        }

        function getComponentById(id) {
          return state.components.find(component => component.id === id) || null;
        }

        function getConnectorByKey(componentId, key) {
          const component = getComponentById(componentId);
          if (!component) return null;
          return component.connectors.find(connector => connector.key === key) || null;
        }

        function getConnectorId(componentId, key) {
          const connector = getConnectorByKey(componentId, key);
          return connector ? connector.id : null;
        }

        function buildToolButtons() {
          toolButtonsContainer.innerHTML = '';
          toolModes.forEach(mode => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'tool-button';
            button.dataset.toolMode = mode.id;
            button.textContent = mode.label;
            button.addEventListener('click', () => setToolMode(mode.id));
            toolButtonsContainer.appendChild(button);
          });
          updateToolButtons();
        }

        function setToolMode(mode) {
          if (mode === state.toolMode) return;
          closeSleeveMenu();
          state.toolMode = mode;
          if (state.activeWire && state.toolMode !== 'draw') {
            cancelActiveWire();
          }
          state.hoverWireId = null;
          if ((state.toolMode === 'erase' || state.toolMode === 'mark') && state.pendingComponentType) {
            state.pendingComponentType = null;
            updateComponentPaletteUI();
          }
          if (mode !== 'mark') {
            state.showSleeveMarks = false;
          }
          updateToolButtons();
          updateStatusTip();
          draw();
        }

        function updateColorUI() {
          const selectedOption =
            conductorOptions.find(option => option.color === state.selectedColor) || conductorOptions[0];
          state.selectedColor = selectedOption.color;
          document.querySelectorAll('.color-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.color === state.selectedColor);
          });
          selectedColorLabel.textContent = selectedOption.label;
        }

        function updateGaugeUI() {
          const selectedOption =
            conductorGaugeOptions.find(option => option.value === state.selectedGauge) || conductorGaugeOptions[0];
          state.selectedGauge = selectedOption.value;
          if (gaugeSelectorContainer) {
            gaugeSelectorContainer.querySelectorAll('.gauge-button').forEach(btn => {
              btn.classList.toggle('active', btn.dataset.gauge === state.selectedGauge);
            });
          }
          if (selectedGaugeLabel) {
            selectedGaugeLabel.textContent = selectedOption.label;
          }
        }

        function updateSleeveUI() {
          const selectedOption =
            sleeveOptions.find(option => option.id === state.selectedSleeveType) || sleeveOptions[0];
          state.selectedSleeveType = selectedOption.id;
          if (sleeveButtonsContainer) {
            sleeveButtonsContainer.querySelectorAll('.gauge-button').forEach(btn => {
              btn.classList.toggle('active', btn.dataset.sleeve === state.selectedSleeveType);
            });
          }
        }

        function openSleeveMenu(junction, clientX, clientY) {
          state.showSleeveMarks = true;
          if (!sleeveMenu) return;
          sleeveMenu.innerHTML = '';
          sleeveOptions.forEach(option => {
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = option.mark + ' ' + option.label;
            button.addEventListener('click', () => {
              recordHistory();
              junction.sleeveType = option.id;
              closeSleeveMenu();
              updateStatusTip('接続点"' + junction.label + '"に ' + option.label + ' を設定しました');
              draw();
            });
            sleeveMenu.appendChild(button);
          });
          const { x, y } = calculateGenericMenuPosition(sleeveMenu, clientX, clientY);
          sleeveMenu.style.left = x + 'px';
          sleeveMenu.style.top = y + 'px';
          sleeveMenu.classList.add('open');
          sleeveMenu.setAttribute('aria-hidden', 'false');
          state.sleeveMenu = { isOpen: true, junctionId: junction.id };
        }

        function closeSleeveMenu() {
          if (!state.sleeveMenu.isOpen) return;
          state.sleeveMenu = { isOpen: false, junctionId: null };
          if (sleeveMenu) {
            sleeveMenu.classList.remove('open');
            sleeveMenu.setAttribute('aria-hidden', 'true');
          }
        }

        function openWireMenu(targetWire, clientX, clientY) {
          if (!wireMenu) return;
          wireMenu.innerHTML = '';
          wireColorGaugeOptions.forEach(option => {
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = option.label;
            button.style.color = getConductorStroke(option.color);
            button.addEventListener('click', () => {
              recordHistory();
              targetWire.color = option.color;
              targetWire.gauge = option.gauge;
              closeWireMenu();
              updateStatusTip('配線を ' + option.label + ' に変更しました');
              draw();
            });
            wireMenu.appendChild(button);
          });
          const { x, y } = calculateGenericMenuPosition(wireMenu, clientX, clientY);
          wireMenu.style.left = x + 'px';
          wireMenu.style.top = y + 'px';
          wireMenu.classList.add('open');
          wireMenu.setAttribute('aria-hidden', 'false');
          state.wireMenu = { isOpen: true, wireId: targetWire.id };
        }

        function closeWireMenu() {
          if (!state.wireMenu.isOpen) return;
          state.wireMenu = { isOpen: false, wireId: null };
          if (wireMenu) {
            wireMenu.classList.remove('open');
            wireMenu.setAttribute('aria-hidden', 'true');
          }
        }

        function calculateGenericMenuPosition(menuElement, clientX, clientY) {
          const defaultRect = { width: 160, height: 120 };
          const rect = menuElement ? { width: menuElement.offsetWidth || defaultRect.width, height: menuElement.offsetHeight || defaultRect.height } : defaultRect;
          const margin = 8;
          let x = clientX + margin;
          let y = clientY + margin;
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          if (x + rect.width > viewportWidth) {
            x = clientX - rect.width - margin;
          }
          if (y + rect.height > viewportHeight) {
            y = clientY - rect.height - margin;
          }
          return { x: Math.max(margin, x), y: Math.max(margin, y) };
        }

        function updateToolButtons() {
          document.querySelectorAll('.tool-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.toolMode === state.toolMode);
          });
          if (state.toolMode === 'erase') {
            canvas.style.cursor = 'not-allowed';
          } else if (state.toolMode === 'mark') {
            canvas.style.cursor = 'text';
          } else {
            canvas.style.cursor = 'crosshair';
          }
          if (
            state.draggingComponent ||
            (state.draggingJunction && state.draggingJunction.isDragging)
          ) {
            canvas.style.cursor = 'grabbing';
          }
        }

        function toggleSwitch() {
          const primarySwitch = state.primaryIds.switch ? getComponentById(state.primaryIds.switch) : null;
          if (!primarySwitch) {
            updateStatusTip('スイッチが配置されていません');
            state.switchClosed = false;
            updateSwitchUI();
            return;
          }
          recordHistory();
          state.switchClosed = !state.switchClosed;
          updateSwitchUI();
          updateStatusTip(state.switchClosed ? 'スイッチを入れました' : 'スイッチを切りました');
          draw();
        }

        function updateSwitchUI() {
          if (!switchToggle) return;
          const primarySwitch = state.primaryIds.switch ? getComponentById(state.primaryIds.switch) : null;
          const hasSwitch = Boolean(primarySwitch);
          switchToggle.disabled = !hasSwitch;
          if (hasSwitch) {
            const isOn = state.switchClosed;
            switchToggle.textContent = isOn ? '入 (ON)' : '切 (OFF)';
            switchToggle.classList.toggle('on', isOn);
            switchToggle.setAttribute('aria-pressed', isOn ? 'true' : 'false');
          } else {
            switchToggle.textContent = 'スイッチ未配置';
            switchToggle.classList.remove('on');
            switchToggle.setAttribute('aria-pressed', 'false');
          }
        }

        function updateLampStatusUI() {
          if (!lampStatusLabel) return;
          lampStatusLabel.textContent = state.lampOn ? '点灯' : '消灯';
          lampStatusLabel.classList.toggle('on', state.lampOn);
        }

        function updateOutletStatusUI() {
          if (!outletStatusLabel) return;
          const statuses = state.outletStatuses;
          if (!statuses || statuses.size === 0) {
            outletStatusLabel.textContent = '未配置';
            outletStatusLabel.classList.remove('on');
            outletStatusLabel.classList.remove('partial');
            return;
          }
          const values = Array.from(statuses.values());
          const energizedCount = values.filter(status => status.energized).length;
          const partialCount = values.filter(status =>
            !status.energized && (status.hotConnected || status.neutralConnected)
          ).length;
          let labelText = '';
          if (energizedCount === statuses.size && statuses.size > 0) {
            labelText = '全口通電';
          } else if (energizedCount > 0) {
            labelText = energizedCount + '/' + statuses.size + '口通電';
          } else if (partialCount > 0) {
            labelText = '片側のみ接続';
          } else {
            labelText = '未接続';
          }
          outletStatusLabel.textContent = labelText;
          const allFunctional = energizedCount > 0 && energizedCount === statuses.size;
          const hasPartial = !allFunctional && (energizedCount > 0 || partialCount > 0);
          outletStatusLabel.classList.toggle('on', allFunctional);
          outletStatusLabel.classList.toggle('partial', hasPartial);
        }

        function bindEvents() {
          canvas.addEventListener('mousedown', onPointerDown);
          canvas.addEventListener('mousemove', onPointerMove);
          canvas.addEventListener('mouseleave', onPointerLeave);
          canvas.addEventListener('dblclick', onCanvasDoubleClick);
          canvas.addEventListener('contextmenu', evt => evt.preventDefault());
          window.addEventListener('resize', debounce(resizeCanvas, 150));
          window.addEventListener('keydown', evt => {
            if (evt.key === 'Escape') {
              if (state.activeWire) {
                cancelActiveWire();
                draw();
                return;
              }
              if (state.pendingComponentType) {
                state.pendingComponentType = null;
                updateComponentPaletteUI();
                updateStatusTip('器具の選択を取消しました');
              }
            }
          });
          window.addEventListener('mouseup', onPointerUp);
        }

        function onPointerDown(evt) {
          if (evt.button !== 0) return;
          const point = getCanvasPoint(evt);
          state.pointer = point;
          if (!evt.ctrlKey) {
            closeSleeveMenu();
            closeWireMenu();
          }

          if (evt.altKey && !evt.ctrlKey) {
            const targetComponent = findComponentAt(point);
            if (targetComponent && canRotateComponent(targetComponent)) {
              recordHistory();
              const step = evt.shiftKey ? -90 : 90;
              rotateComponentInstance(targetComponent, step);
              const template = componentTemplates[targetComponent.type];
              const displayName = template ? template.displayName : (targetComponent.label || '').replace(/\n/g, ' ');
              const directionLabel = step > 0 ? '時計回りに' : '反時計回りに';
              updateStatusTip((displayName || '器具') + 'を' + directionLabel + '90°回転しました');
              draw();
              return;
            }
          }

          if (evt.ctrlKey) {
            if (state.activeWire) {
              cancelActiveWire();
            }
            const junction = findJunctionNear(point, 18);
            if (junction) {
              closeSleeveMenu();
              closeWireMenu();
              openSleeveMenu(junction, evt.clientX, evt.clientY);
              return;
            }
            const hit = findWireSegment(point);
            if (hit && hit.distance <= 14) {
              closeSleeveMenu();
              closeWireMenu();
              openWireMenu(hit.wire, evt.clientX, evt.clientY);
              return;
            }
            updateStatusTip('近くに接続点や配線がありません');
            closeSleeveMenu();
            closeWireMenu();
            return;
          }

          if (state.toolMode === 'mark') {
            const junction = findJunctionNear(point, 14);
            if (junction) {
              recordHistory();
              junction.sleeveType = state.selectedSleeveType;
              updateStatusTip('接続点"' + junction.label + '"に刻印を設定しました');
              draw();
            } else {
              updateStatusTip('刻印したい接続点をクリックしてください');
            }
            return;
          }

          if (state.pendingComponentType && state.toolMode !== 'erase') {
            if (placePendingComponent(point)) {
              return;
            }
          }

          if (state.toolMode === 'erase') {
            eraseAt(point);
            return;
          }

          if (tryStartComponentDrag(point)) {
            draw();
            return;
          }

          if (!state.activeWire) {
            if (tryStartJunctionDrag(point)) {
              draw();
              return;
            }
          }

          const connectorTarget = findConnectorAt(point);

          if (state.activeWire) {
            if (connectorTarget && connectorTarget.id !== state.activeWire.startConnectorId) {
              finalizeActiveWire(connectorTarget);
            } else if (!connectorTarget) {
              commitActiveWireCorner(point);
            }
          }
          draw();
        }

        function onPointerMove(evt) {
          const point = getCanvasPoint(evt);
          state.pointer = point;

          if (state.toolMode === 'mark') {
            const junction = findJunctionNear(point, 14);
            state.hoverConnectorId = junction ? junction.id : null;
            draw();
            return;
          }

          if (state.draggingComponent) {
            updateComponentDrag(point);
            draw();
            return;
          }
          if (state.draggingJunction) {
            updateJunctionDrag(point);
            draw();
            return;
          }

          const connectorTarget = findConnectorAt(point);
          state.hoverConnectorId = connectorTarget ? connectorTarget.id : null;

          if (state.toolMode === 'erase') {
            const hit = findWireSegment(point);
            state.hoverWireId = hit && hit.distance <= 12 ? hit.wire.id : null;
          } else {
            state.hoverWireId = null;
            if (state.activeWire) {
              const snapPoint = connectorTarget ? connectorTarget.position : point;
              updateActiveWirePreview(snapPoint);
            }
          }
          draw();
        }

        function onPointerLeave() {
          if (state.draggingComponent || state.draggingJunction) return;
          state.hoverConnectorId = null;
          state.hoverWireId = null;
          if (state.activeWire) {
            const pts = state.activeWire.points;
            updateActiveWirePreview(pts[pts.length - 1]);
          }
          draw();
        }

        function onPointerUp() {
          if (state.draggingComponent) {
            endComponentDrag();
            draw();
            return;
          }
          if (state.draggingJunction) {
            endJunctionDrag();
            draw();
          }
        }

        function onCanvasDoubleClick(evt) {
          evt.preventDefault();
          if (state.draggingComponent) return;
          if (state.draggingJunction) {
            endJunctionDrag();
          }
          const point = getCanvasPoint(evt);
          const connectorTarget = findConnectorAt(point);

          if (state.activeWire) {
            if (connectorTarget) {
              if (connectorTarget.id !== state.activeWire.startConnectorId) {
                finalizeActiveWire(connectorTarget);
              }
            } else {
              recordHistory();
              const junction = createJunction(point);
              finalizeActiveWire({ id: junction.id, position: { x: junction.x, y: junction.y } });
            }
            draw();
            return;
          }

          if (connectorTarget) {
            startWire(connectorTarget);
            draw();
            return;
          }

          const hit = findWireSegment(point);
          if (hit && hit.distance <= 14) {
            const existing = state.junctions.find(j => distance(point, j) < 12);
            const projection = hit.projection;
            const junction = existing ? existing : insertJunction(hit.wire, hit.segmentIndex, projection);
            state.hoverConnectorId = junction.id;
            draw();
            return;
          }

          recordHistory();
          const newJunction = createJunction(point);
          state.hoverConnectorId = newJunction.id;
          draw();
        }

        function tryStartComponentDrag(point) {
          const target = findComponentAt(point);
          if (!target) return false;
          recordHistory();
          const offset = { x: point.x - target.position.x, y: point.y - target.position.y };
          state.draggingComponent = { component: target, offset };
          canvas.style.cursor = 'grabbing';
          updateStatusTip('ドラッグで機器を移動');
          return true;
        }

        function updateComponentDrag(point) {
          const { component, offset } = state.draggingComponent;
          component.position.x = point.x - offset.x;
          component.position.y = point.y - offset.y;
        }

        function endComponentDrag() {
          state.draggingComponent = null;
          canvas.style.cursor = state.toolMode === 'erase' ? 'not-allowed' : 'crosshair';
          updateStatusTip();
        }

        function tryStartJunctionDrag(point) {
          if (state.draggingJunction) return true;
          const junction = findJunctionNear(point, 10);
          if (!junction) return false;
          recordHistory();
          state.draggingJunction = {
            junction,
            offset: { x: point.x - junction.x, y: point.y - junction.y },
            startPoint: { x: point.x, y: point.y },
            isDragging: false
          };
          state.hoverConnectorId = junction.id;
          return true;
        }

        function updateJunctionDrag(point) {
          if (!state.draggingJunction) return;
          const data = state.draggingJunction;
          const distanceMoved = Math.hypot(point.x - data.startPoint.x, point.y - data.startPoint.y);
          if (!data.isDragging && distanceMoved >= 3) {
            data.isDragging = true;
            canvas.style.cursor = 'grabbing';
            updateStatusTip('ドラッグで接続点を移動');
          }
          if (!data.isDragging) return;
          const { junction, offset } = data;
          junction.x = point.x - offset.x;
          junction.y = point.y - offset.y;
          state.junctionIndex.set(junction.id, junction);
          state.hoverConnectorId = junction.id;
        }

        function endJunctionDrag() {
          if (!state.draggingJunction) return;
          const wasDragging = state.draggingJunction.isDragging;
          state.draggingJunction = null;
          if (wasDragging) {
            canvas.style.cursor = state.toolMode === 'erase' ? 'not-allowed' : 'crosshair';
            updateStatusTip();
          }
        }

        function startWire(connectorTarget) {
          const startPoint = { x: connectorTarget.position.x, y: connectorTarget.position.y };
          state.counters.wire += 1;
          state.activeWire = {
            id: 'wire-' + state.counters.wire,
            color: state.selectedColor,
            gauge: state.selectedGauge,
            points: [startPoint, { x: startPoint.x, y: startPoint.y }],
            startConnectorId: connectorTarget.id,
            endConnectorId: null
          };
          updateStatusTip('配線中: 終了コネクタをクリック (Escで取消)');
        }

        function updateActiveWirePreview(point) {
          if (!state.activeWire) return;
          const pts = state.activeWire.points;
          pts[pts.length - 1] = { x: point.x, y: point.y };
        }

        function commitActiveWireCorner(point) {
          if (!state.activeWire) return;
          const pts = state.activeWire.points;
          pts[pts.length - 1] = { x: point.x, y: point.y };
          pts.push({ x: point.x, y: point.y });
        }

        function finalizeActiveWire(connectorTarget) {
          const wire = state.activeWire;
          if (!wire) return;
          if (connectorTarget.id === wire.startConnectorId) {
            cancelActiveWire();
            return;
          }
          const endPoint = { x: connectorTarget.position.x, y: connectorTarget.position.y };
          wire.points[wire.points.length - 1] = endPoint;
          simplifyWirePoints(wire);
          if (wire.points.length < 2) {
            cancelActiveWire();
            return;
          }
          wire.endConnectorId = connectorTarget.id;
          recordHistory();
          state.wires.push(wire);
          state.activeWire = null;
          const { errors, warnings } = validateConductorAssignments();
          if (errors.length) {
            updateStatusTip(errors[0]);
          } else if (warnings.length) {
            updateStatusTip(warnings[0]);
          } else {
            updateStatusTip();
          }
        }

        function cancelActiveWire() {
          state.activeWire = null;
          updateStatusTip();
        }

        function eraseAt(point) {
          const component = state.toolMode === 'erase' ? findComponentAt(point) : null;
          if (component) {
            removeComponent(component);
            const template = componentTemplates[component.type];
            const label = template ? template.displayName : component.label;
            updateStatusTip(label + 'を削除しました');
            draw();
            return;
          }

          const junction = findJunctionNear(point, 20);
          if (junction) {
            removeJunction(junction);
            state.hoverConnectorId = null;
            updateStatusTip('接続点を削除しました');
            draw();
            return;
          }
          const hit = findWireSegment(point);
          if (hit && hit.distance <= 12) {
            recordHistory();
            state.wires = state.wires.filter(w => w.id !== hit.wire.id);
            state.hoverWireId = null;
            if (state.wireMenu.isOpen && state.wireMenu.wireId === hit.wire.id) {
              closeWireMenu();
            }
            updateStatusTip('配線を削除しました');
            draw();
          } else {
            updateStatusTip('削除したいオブジェクトをクリックしてください');
          }
        }

        function removeComponent(component) {
          recordHistory();
          const connectorIds = new Set(component.connectors.map(connector => connector.id));
          state.components = state.components.filter(item => item.id !== component.id);

          state.wires = state.wires.filter(wire => {
            const remove = connectorIds.has(wire.startConnectorId) || connectorIds.has(wire.endConnectorId);
            return !remove;
          });
          if (state.wireMenu.isOpen && !state.wires.some(wire => wire.id === state.wireMenu.wireId)) {
            closeWireMenu();
          }

          if (state.hoverWireId && !state.wires.some(wire => wire.id === state.hoverWireId)) {
            state.hoverWireId = null;
          }

          if (state.hoverConnectorId && connectorIds.has(state.hoverConnectorId)) {
            state.hoverConnectorId = null;
          }

          cleanupJunctions();

          if (state.pairingAssignments.has(component.id)) {
            state.pairingAssignments.delete(component.id);
            syncPairingLabels();
          }
          buildPairingControls();

          if (Object.prototype.hasOwnProperty.call(state.primaryIds, component.type) &&
            state.primaryIds[component.type] === component.id) {
            const replacement = state.components.find(item => item.type === component.type) || null;
            state.primaryIds[component.type] = replacement ? replacement.id : null;
            if (component.type === 'switch') {
              state.switchClosed = false;
              updateSwitchUI();
            }
          }

          if (component.type === 'power' && !state.primaryIds.power) {
            state.switchClosed = false;
            updateSwitchUI();
          }
          if (component.type === 'lamp' && !state.primaryIds.lamp) {
            state.lampOn = false;
          }
          if (component.type === 'pilot' && !state.components.some(item => item.type === 'pilot')) {
            state.pilotOn = false;
          }

          rebuildConnectorIndex();
        }

        function cleanupJunctions() {
          const usedJunctionIds = new Set();
          state.wires.forEach(wire => {
            if (state.junctionIndex.has(wire.startConnectorId)) {
              usedJunctionIds.add(wire.startConnectorId);
            }
            if (state.junctionIndex.has(wire.endConnectorId)) {
              usedJunctionIds.add(wire.endConnectorId);
            }
          });
        state.junctions = state.junctions.filter(junction => usedJunctionIds.has(junction.id));
        state.junctionIndex = new Map();
        state.junctions.forEach(junction => {
          state.junctionIndex.set(junction.id, junction);
        });
        }

        function updateStatusTip(message) {
          if (state.statusResetTimer) {
            window.clearTimeout(state.statusResetTimer);
            state.statusResetTimer = null;
          }
          if (message) {
            statusTip.textContent = message;
            state.statusResetTimer = window.setTimeout(() => {
              state.statusResetTimer = null;
              updateStatusTip();
            }, 1600);
            return;
          }
          if (state.toolMode === 'erase') {
            statusTip.textContent = '消したい器具や配線をクリックしてください';
          } else if (state.toolMode === 'mark') {
            const sleeveOption = getSleeveOptionById(state.selectedSleeveType);
            statusTip.textContent = (sleeveOption.mark || '') + '刻印: 接続点をクリックしてください';
          } else if (state.activeWire) {
            statusTip.textContent = '配線中: 終了コネクタをクリック (Escで取消)';
          } else if (state.draggingComponent) {
            statusTip.textContent = 'ドラッグで機器を移動';
          } else if (state.draggingJunction && state.draggingJunction.isDragging) {
            statusTip.textContent = 'ドラッグで接続点を移動';
          } else {
            statusTip.textContent = '器具パレットで器具を追加し、配線したいコネクタをダブルクリックしてください (Ctrl+クリックでスリーブ刻印)';
          }
        }

        function simplifyWirePoints(wire) {
          const simplified = [wire.points[0]];
          for (let i = 1; i < wire.points.length; i += 1) {
            const prev = simplified[simplified.length - 1];
            const point = wire.points[i];
            if (Math.hypot(point.x - prev.x, point.y - prev.y) > 0.5) {
              simplified.push(point);
            }
          }
          wire.points = simplified;
        }

        function resizeCanvas() {
          const rect = canvas.getBoundingClientRect();
          if (!rect.width || !rect.height) return;
          const ratio = window.devicePixelRatio || 1;
          canvas.width = rect.width * ratio;
          canvas.height = rect.height * ratio;
          ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
          draw();
        }

        function draw() {
          evaluateCircuit();
          updateLampStatusUI();
          updateOutletStatusUI();
          const ratio = window.devicePixelRatio || 1;
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();

          const width = canvas.width / ratio;
          const height = canvas.height / ratio;

          drawGrid(width, height);
          drawWires(state.wires);
          if (state.activeWire) {
            drawWire(state.activeWire, { preview: true });
          }
          drawComponents();
          drawJunctions();
        }

        function drawGrid(width, height) {
          const spacing = 40;
          ctx.save();
          ctx.strokeStyle = '#e2e8f0';
          ctx.lineWidth = 1;
          ctx.beginPath();
          for (let x = spacing; x < width; x += spacing) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
          }
          for (let y = spacing; y < height; y += spacing) {
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
          }
          ctx.stroke();
          ctx.restore();
        }

        function drawWires(wires, options = {}) {
          wires.forEach(wire => {
            syncWireEndpoints(wire);
            const highlight = state.toolMode === 'erase' && state.hoverWireId === wire.id;
            drawWire(wire, { ...options, highlight });
          });
        }

        function drawWire(wire, { preview = false, highlight = false } = {}) {
          if (wire.points.length < 2) return;
          const color = getConductorStroke(wire.color || 'black');
          const gauge = wire.gauge || conductorGaugeOptions[0].value;
          const baseWidth = gauge === '2.0' ? 6 : 4;
          ctx.save();
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.strokeStyle = color;
          ctx.lineWidth = highlight ? baseWidth + 2 : baseWidth;
          if (preview) {
            ctx.globalAlpha = 0.7;
            ctx.setLineDash([6, 6]);
          } else if (highlight) {
            ctx.setLineDash([4, 4]);
          }
          ctx.beginPath();
          ctx.moveTo(wire.points[0].x, wire.points[0].y);
          for (let i = 1; i < wire.points.length; i += 1) {
            ctx.lineTo(wire.points[i].x, wire.points[i].y);
          }
          ctx.stroke();
          ctx.restore();
        }

        function drawComponents() {
          state.components.forEach(component => {
            switch (component.type) {
              case 'power':
                drawPower(component);
                break;
              case 'switch':
                drawSwitch(component);
                break;
              case 'outlet':
                drawOutlet(component);
                break;
              case 'lamp':
                drawLamp(component);
                break;
              case 'pilot':
                drawPilotLamp(component);
                break;
              default:
                drawGeneric(component);
                break;
            }
            component.connectors.forEach(connector => {
              const position = getConnectorPositionById(connector.id);
              drawConnectorNode(position, connector);
            });
          });
        }

        function drawComponentWithRotation(component, drawFn) {
          const baseSize = component.baseSize || component.size;
          const rotation = normalizeRotation(component.rotation || 0);
          const center = getComponentCenter(component);
          ctx.save();
          ctx.translate(center.x, center.y);
          ctx.rotate((rotation * Math.PI) / 180);
          ctx.translate(-baseSize.width / 2, -baseSize.height / 2);
          drawFn({ x: 0, y: 0, width: baseSize.width, height: baseSize.height });
          ctx.restore();
        }

        function drawPower(component) {
          const { x, y } = component.position;
          const { width, height } = component.size;
          ctx.save();
          ctx.strokeStyle = '#0f172a';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, width, height);
          ctx.fillStyle = '#f8fafc';
          ctx.fillRect(x, y, width, height);
          ctx.fillStyle = '#1e293b';
          ctx.font = '14px "Segoe UI", sans-serif';
          ctx.textBaseline = 'top';
          const lines = component.label.split('\n');
          lines.forEach((line, idx) => ctx.fillText(line, x + 16, y + 16 + idx * 18));
          ctx.restore();
        }

        function drawSwitch(component) {
          drawComponentWithRotation(component, ({ width, height }) => {
            const x = 0;
            const y = 0;
            ctx.save();
            const isOn = state.switchClosed;
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(x, y, width, height);
            const leftContact = {
              x: x + 22,
              y: y + height / 2
            };
            const rightContact = {
              x: x + width - 22,
              y: y + height / 2
            };
            ctx.fillStyle = '#0f172a';
            ctx.beginPath();
            ctx.arc(leftContact.x, leftContact.y, 5, 0, Math.PI * 2);
            ctx.arc(rightContact.x, rightContact.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#0f172a';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(leftContact.x, leftContact.y);
            if (isOn) {
              ctx.lineTo(rightContact.x, rightContact.y);
            } else {
              ctx.lineTo(rightContact.x - 12, rightContact.y - 18);
            }
            ctx.stroke();
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(leftContact.x - 14, leftContact.y);
            ctx.lineTo(leftContact.x - 5, leftContact.y);
            ctx.moveTo(rightContact.x + 5, rightContact.y);
            ctx.lineTo(rightContact.x + 14, rightContact.y);
            ctx.stroke();
            ctx.restore();
          });
          const { position, size } = component;
          const cx = position.x + size.width / 2;
          const switchLabel = getPairingDisplayLabel(component.id);
          ctx.save();
          ctx.font = '14px "Segoe UI", sans-serif';
          ctx.fillStyle = '#1f2937';
          ctx.textAlign = 'center';
          ctx.fillText(component.label, cx, position.y - 10);
          ctx.font = '12px "Segoe UI", sans-serif';
          ctx.fillText(state.switchClosed ? '入' : '切', cx, position.y + size.height - 12);
          if (switchLabel) {
            ctx.font = 'bold 18px "Segoe UI", sans-serif';
            ctx.fillStyle = '#c2410c';
            ctx.textAlign = 'right';
            ctx.fillText(switchLabel, position.x + size.width - 6, position.y + 18);
          }
          ctx.restore();
        }

        function drawOutlet(component) {
          const status = state.outletStatuses.get(component.id);
          const isEnergized = status ? status.energized : false;
          const isPartial = status ? !status.energized && (status.hotConnected || status.neutralConnected) : false;
          const ringColor = isEnergized ? '#15803d' : isPartial ? '#b45309' : '#1f2937';
          const fillColor = isEnergized ? '#ecfdf5' : '#ffffff';
          const labelColor = isEnergized ? '#166534' : isPartial ? '#b45309' : '#1f2937';
          drawComponentWithRotation(component, ({ width, height }) => {
            const x = 0;
            const y = 0;
            const cx = x + width / 2;
            const cy = y + height / 2;
            const radius = Math.min(width, height) / 2.6;
            ctx.save();
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(x, y, width, height);
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = ringColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            const slotOffset = radius * 0.55;
            const slotHeight = radius * 0.9;
            ctx.beginPath();
            ctx.moveTo(cx - slotOffset, cy - slotHeight / 2);
            ctx.lineTo(cx - slotOffset, cy + slotHeight / 2);
            ctx.moveTo(cx + slotOffset, cy - slotHeight / 2);
            ctx.lineTo(cx + slotOffset, cy + slotHeight / 2);
            ctx.strokeStyle = ringColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
          });
          const { position, size } = component;
          const cx = position.x + size.width / 2;
          ctx.save();
          ctx.font = '14px "Segoe UI", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'alphabetic';
          ctx.fillStyle = labelColor;
          ctx.fillText(component.label, cx, position.y - 12);
          if (status) {
            ctx.font = '12px "Segoe UI", sans-serif';
            ctx.fillText(
              isEnergized ? '使用可' : isPartial ? '要確認' : '未接続',
              cx,
              position.y + size.height - 12
            );
          }
          ctx.restore();
        }

        function drawLamp(component) {
          const isOn = state.lampOn;
          drawComponentWithRotation(component, ({ width, height }) => {
            const x = 0;
            const y = 0;
            const cx = x + width / 2;
            const cy = y + height / 2;
            const radius = Math.min(width, height) / 2.8;
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = isOn ? '#fde68a' : '#f8fafc';
            ctx.fill();
            ctx.strokeStyle = isOn ? '#f59e0b' : '#1f2937';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.font = 'bold 26px "Segoe UI", sans-serif';
            ctx.fillStyle = isOn ? '#b45309' : '#1f2937';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('R', cx, cy);
            ctx.restore();
          });
          const { position, size } = component;
          const cx = position.x + size.width / 2;
          const lampLabel = getPairingDisplayLabel(component.id);
          ctx.save();
          ctx.font = '14px "Segoe UI", sans-serif';
          ctx.fillStyle = '#1f2937';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'alphabetic';
          ctx.fillText(component.label, cx, position.y - 12);
          if (lampLabel) {
            ctx.font = 'bold 18px "Segoe UI", sans-serif';
            ctx.fillStyle = '#c2410c';
            ctx.textBaseline = 'middle';
            ctx.fillText(lampLabel, cx, position.y + size.height + 16);
          }
          ctx.restore();
        }

        function drawPilotLamp(component) {
          const isOn = state.pilotOn;
          drawComponentWithRotation(component, ({ width, height }) => {
            const x = 0;
            const y = 0;
            const cx = x + width / 2;
            const cy = y + height / 2;
            const radius = Math.min(width, height) / 3.6;
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = isOn ? '#fde68a' : '#f8fafc';
            ctx.fill();
            ctx.strokeStyle = isOn ? '#f59e0b' : '#1f2937';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = 'bold 18px "Segoe UI", sans-serif';
            ctx.fillStyle = isOn ? '#b45309' : '#1f2937';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('P', cx, cy);
            ctx.restore();
          });
          const { position, size } = component;
          const cx = position.x + size.width / 2;
          const pilotLabel = getPairingDisplayLabel(component.id);
          ctx.save();
          ctx.font = '12px "Segoe UI", sans-serif';
          ctx.fillStyle = '#1f2937';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'alphabetic';
          ctx.fillText(component.label, cx, position.y - 8);
          if (pilotLabel) {
            ctx.font = 'bold 16px "Segoe UI", sans-serif';
            ctx.fillStyle = '#c2410c';
            ctx.textBaseline = 'middle';
            ctx.fillText(pilotLabel, cx, position.y + size.height + 14);
          }
          ctx.restore();
        }

        function drawGeneric(component) {
          const { x, y } = component.position;
          const { width, height } = component.size;
          ctx.save();
          ctx.strokeStyle = '#0f172a';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, width, height);
          ctx.font = '14px "Segoe UI", sans-serif';
          ctx.fillStyle = '#0f172a';
          ctx.textAlign = 'center';
          ctx.fillText(component.label, x + width / 2, y - 12);
          ctx.restore();
        }

        function drawConnectorNode(position, connector) {
          if (!position) return;
          ctx.save();
          const radius = 8;
          const isHover = state.hoverConnectorId === connector.id;
          ctx.fillStyle = isHover ? '#dbeafe' : '#ffffff';
          ctx.strokeStyle = isHover ? '#2563eb' : '#0f172a';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.font = '12px "Segoe UI", sans-serif';
          ctx.fillStyle = '#0f172a';
          ctx.textAlign = 'center';
          ctx.fillText(connector.label, position.x, position.y + 20);
          ctx.restore();
        }

        function drawJunctions() {
          state.junctions.forEach(junction => {
            ctx.save();
            const isHover = state.hoverConnectorId === junction.id;
            const showMark = state.showSleeveMarks;
            ctx.fillStyle = showMark ? (isHover ? '#fef3c7' : '#f1f5f9') : (isHover ? '#dbeafe' : '#ffffff');
            ctx.strokeStyle = isHover ? '#2563eb' : '#475569';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(junction.x, junction.y, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            if (showMark) {
              const sleeveOption = getSleeveOptionById(junction.sleeveType);
              if (sleeveOption && sleeveOption.mark) {
                ctx.font = '12px "Segoe UI", sans-serif';
                ctx.fillStyle = '#1f2937';
                ctx.textAlign = 'center';
                ctx.fillText(sleeveOption.mark, junction.x, junction.y - 10);
              }
              ctx.font = '11px "Segoe UI", sans-serif';
              ctx.fillStyle = '#b45309';
              ctx.textAlign = 'center';
              ctx.fillText(junction.label, junction.x, junction.y + 18);
            } else if (isHover) {
              ctx.font = '12px "Segoe UI", sans-serif';
              ctx.fillStyle = '#1f2937';
              ctx.textAlign = 'center';
              ctx.fillText(junction.label, junction.x, junction.y + 18);
            }
            ctx.restore();
          });
        }

        function createJunction(point) {
          state.counters.junction += 1;
          const junction = {
            id: 'junction-' + state.counters.junction,
            label: 'J' + state.counters.junction,
            x: point.x,
            y: point.y,
            sleeveType: null
          };
          state.junctions.push(junction);
          state.junctionIndex.set(junction.id, junction);
          return junction;
        }

        function findJunctionNear(point, radius = 12) {
          return (
            state.junctions.find(junction => distance(point, junction) <= radius) || null
          );
        }

        function removeJunction(junction) {
          recordHistory();
          state.junctions = state.junctions.filter(j => j.id !== junction.id);
          state.junctionIndex.delete(junction.id);
          state.wires = state.wires.filter(wire => wire.startConnectorId !== junction.id && wire.endConnectorId !== junction.id);
          if (state.sleeveMenu.isOpen && state.sleeveMenu.junctionId === junction.id) {
            closeSleeveMenu();
          }
        }

        function evaluateCircuit() {
          const adjacency = new Map();

          function addEdge(a, b) {
            if (!a || !b) return;
            if (!adjacency.has(a)) adjacency.set(a, new Set());
            if (!adjacency.has(b)) adjacency.set(b, new Set());
            adjacency.get(a).add(b);
            adjacency.get(b).add(a);
          }

          state.wires.forEach(wire => {
            if (!wire.startConnectorId || !wire.endConnectorId) return;
            addEdge(wire.startConnectorId, wire.endConnectorId);
          });

          const primaryPowerId = state.primaryIds.power;
          const primaryLampId = state.primaryIds.lamp;
          const primarySwitchId = state.primaryIds.switch;

          const powerHotId = primaryPowerId ? getConnectorId(primaryPowerId, 'hot') : null;
          const powerNeutralId = primaryPowerId ? getConnectorId(primaryPowerId, 'neutral') : null;
          const lampHotId = primaryLampId ? getConnectorId(primaryLampId, 'hot') : null;
          const lampNeutralId = primaryLampId ? getConnectorId(primaryLampId, 'neutral') : null;
          const pilotHotIds = state.components
            .filter(component => component.type === 'pilot')
            .map(component => getConnectorId(component.id, 'hot'));
          const pilotNeutralIds = state.components
            .filter(component => component.type === 'pilot')
            .map(component => getConnectorId(component.id, 'neutral'));

          if (state.switchClosed && primarySwitchId) {
            const switchInId = getConnectorId(primarySwitchId, 'in');
            const switchOutId = getConnectorId(primarySwitchId, 'out');
            addEdge(switchInId, switchOutId);
          }

          const hotConnected = hasPath(powerHotId, lampHotId);
          const neutralConnected = hasPath(lampNeutralId, powerNeutralId);

          const lampOn = Boolean(hotConnected && neutralConnected);
          const pilotOn = pilotHotIds.some((hotId, index) => {
            const neutralId = pilotNeutralIds[index];
            return hasPath(powerHotId, hotId) && hasPath(neutralId, powerNeutralId);
          });
          const outletStatuses = new Map();
          state.components.forEach(component => {
            if (component.type !== 'outlet') return;
            const hotId = getConnectorId(component.id, 'hot');
            const neutralId = getConnectorId(component.id, 'neutral');
            const hotPath = hasPath(powerHotId, hotId);
            const neutralPath = hasPath(neutralId, powerNeutralId);
            outletStatuses.set(component.id, {
              hotConnected: hotPath,
              neutralConnected: neutralPath,
              energized: Boolean(hotPath && neutralPath)
            });
          });

          state.outletStatuses = outletStatuses;
          state.lampOn = lampOn;
          state.pilotOn = pilotOn;
          updateSwitchPairings(adjacency);

          function hasPath(start, target) {
            if (!start || !target) return false;
            if (!adjacency.has(start) || !adjacency.has(target)) return false;
            const visited = new Set([start]);
            const queue = [start];
            while (queue.length) {
              const node = queue.shift();
              if (node === target) return true;
              adjacency.get(node).forEach(next => {
                if (!visited.has(next)) {
                  visited.add(next);
                  queue.push(next);
                }
              });
            }
            return false;
          }
        }

        function updateSwitchPairings(adjacency) {
          state.pairingLabels = new Map();
          state.pairingAssignments.forEach((label, componentId) => {
            if (label) {
              state.pairingLabels.set(componentId, label);
            }
          });
          if (!adjacency) return;
          const usedLoads = new Set();
          const pairs = [];
          state.components.forEach(component => {
            if (component.type !== 'switch') return;
            if (state.pairingLabels.has(component.id)) return;
            const outConnector = component.connectors.find(connector => connector.key === 'out');
            if (!outConnector) return;
            const loadConnectorId = findLoadForSwitch(outConnector.id, adjacency, usedLoads);
            if (!loadConnectorId) return;
            const loadEntry = componentConnectorIndex.get(loadConnectorId);
            if (!loadEntry) return;
            if (state.pairingLabels.has(loadEntry.component.id)) return;
            usedLoads.add(loadEntry.component.id);
            pairs.push({ switchId: component.id, loadId: loadEntry.component.id });
          });

          const usedLabels = new Set(state.pairingLabels.values());
          const availableLabels = pairingOptions.filter(label => !usedLabels.has(label));
          pairs.forEach(pair => {
            if (!availableLabels.length) return;
            const label = availableLabels.shift();
            state.pairingLabels.set(pair.switchId, label);
            state.pairingLabels.set(pair.loadId, label);
          });
        }

        function findLoadForSwitch(startConnectorId, adjacency, usedLoads) {
          const queue = [startConnectorId];
          const visited = new Set([startConnectorId]);
          while (queue.length) {
            const current = queue.shift();
            const neighbors = adjacency.get(current);
            if (!neighbors) continue;
            for (const neighbor of neighbors) {
              if (visited.has(neighbor)) continue;
              visited.add(neighbor);
              const entry = componentConnectorIndex.get(neighbor);
              if (entry) {
                const { component, connector } = entry;
                if ((component.type === 'lamp' || component.type === 'pilot') && connector.role === 'switched') {
                  if (!usedLoads.has(component.id)) {
                    return neighbor;
                  }
                }
                if (component.type === 'switch' && connector.key === 'out') {
                  continue;
                }
              }
              queue.push(neighbor);
            }
          }
          return null;
        }

        function validateConductorAssignments() {
          const connectorMap = new Map();
          state.components.forEach(component => {
            component.connectors.forEach(connector => {
              connectorMap.set(connector.id, { component, connector });
            });
          });

        const conductorMap = new Map();
        state.wires.forEach(wire => {
          const key = [wire.startConnectorId, wire.endConnectorId].slice().sort().join('::');
          [wire.startConnectorId, wire.endConnectorId].forEach(connectorId => {
            if (!connectorMap.has(connectorId)) return;
              const entry = connectorMap.get(connectorId);
              const componentId = entry.component.id;
              if (!conductorMap.has(componentId)) {
                conductorMap.set(componentId, new Map());
              }
              const map = conductorMap.get(componentId);
              if (!map.has(connectorId)) {
                map.set(connectorId, new Map());
              }
              const connectionMap = map.get(connectorId);
              if (!connectionMap.has(key)) {
                connectionMap.set(key, new Set());
              }
              connectionMap.get(key).add(wire.color);
          });
        });

        const errors = [];
        const warnings = [];
        state.components
          .filter(component => component.type === 'outlet')
          .forEach(component => {
            const neutralConnector = component.connectors.find(connector => connector.key === 'neutral');
            if (!neutralConnector) return;
            const componentConnections = conductorMap.get(component.id);
            if (!componentConnections) {
              errors.push('コンセントのW側に青色の芯線が接続されていません');
              return;
            }
            const neutralEntry = componentConnections.get(neutralConnector.id);
            if (!neutralEntry) {
              errors.push('コンセントのW側に青色の芯線が接続されていません');
              return;
            }
            let hasBlue = false;
            neutralEntry.forEach(colorSet => {
              if (colorSet.has('blue')) {
                hasBlue = true;
              }
            });
            if (!hasBlue) {
              errors.push('コンセントのW側に青色の芯線が接続されていません');
            }
          });
        conductorMap.forEach((connections, componentId) => {
          const component = getComponentById(componentId);
          if (!component) return;
          if (component.type === 'switch' || component.type === 'pilot') {
            return;
            }
            const involvedColors = new Set();
            connections.forEach(connectionMap => {
              connectionMap.forEach(colorSet => {
                colorSet.forEach(color => involvedColors.add(color));
              });
            });
            const connectorCount = connections.size;
            const colorSet = new Set(involvedColors);
            let isValid = false;
            const requiredColors = component.connectors
              .map(connector => connector.color)
              .filter(color => color);
            const uniqueRequiredColors = Array.from(new Set(requiredColors));
            if (connectorCount < uniqueRequiredColors.length) {
              return;
            }
            const sortedInvolved = Array.from(colorSet).sort();
            const sortedRequired = uniqueRequiredColors.slice().sort();
            if (sortedInvolved.length === sortedRequired.length) {
              isValid = sortedInvolved.every((color, index) => color === sortedRequired[index]);
            }
            if (isValid) {
              return;
            }

            const template = componentTemplates[component.type];
            const name = template ? template.displayName : component.label;
            const colors = Array.from(colorSet).map(colorName => colorDisplayName(colorName)).join('、') || '未接続';
            errors.push(name + 'の芯線色が不正です: ' + colors);
          });

          const connectorUsage = new Map();
          state.wires.forEach(wire => {
            [wire.startConnectorId, wire.endConnectorId].forEach(connectorId => {
              if (!connectorMap.has(connectorId)) return;
              if (!connectorUsage.has(connectorId)) {
                const entry = connectorMap.get(connectorId);
                connectorUsage.set(connectorId, { colors: new Set(), count: 0, component: entry.component, connector: entry.connector });
              }
              const usage = connectorUsage.get(connectorId);
              usage.count += 1;
              usage.colors.add(wire.color);
            });
          });

          connectorUsage.forEach(({ colors, count, component, connector }) => {
            if (count <= 1) return;
            if (component.type === 'switch' || component.type === 'pilot') return;
            const template = componentTemplates[component.type];
            const name = template ? template.displayName : component.label;
            const expectedColor = connector.color;
            const uniqueColors = Array.from(colors);
            if (count === 2 && uniqueColors.length === 1 && uniqueColors[0] === expectedColor) {
              return;
            }
            warnings.push(name + 'のコネクタ"' + connector.label + '"に複数芯線が接続されています');
          });

          return { errors, warnings };
        }

        function validateSleeves() {
          const errors = [];
          const warnings = [];

          if (!state.junctions.length) {
            warnings.push('接続点がありません');
            return { errors, warnings };
          }

          state.junctions.forEach(junction => {
            const connections = getWireConnectionsForJunction(junction.id);
            const profile = summarizeWireProfile(connections);
            const expectedSleeve = recommendSleeve(profile);
            if (connections.totalCount === 0) {
              warnings.push(junction.label + 'は配線が接続されていません');
              return;
            }
            if (!junction.sleeveType) {
              warnings.push(junction.label + 'のスリーブ刻印が未設定です (推奨: ' + expectedSleeve.label + ')');
              return;
            }
            if (junction.sleeveType !== expectedSleeve.id) {
              errors.push(junction.label + 'の刻印が不適合です (推奨: ' + expectedSleeve.label + ')');
            }
          });

          return { errors, warnings };
        }

        function getWireConnectionsForJunction(junctionId) {
          const connections = [];
          state.wires.forEach(wire => {
            if (wire.startConnectorId === junctionId || wire.endConnectorId === junctionId) {
              const gauge = wire.gauge || state.selectedGauge;
              connections.push({ gauge });
            }
          });
          const gaugeCounts = connections.reduce((acc, { gauge }) => {
            if (!acc[gauge]) acc[gauge] = 0;
            acc[gauge] += 1;
            return acc;
          }, {});
          const totalCount = connections.length;
          return { connections, gaugeCounts, totalCount };
        }

        function summarizeWireProfile({ gaugeCounts, totalCount }) {
          const gauge16 = Number(gaugeCounts['1.6'] || 0);
          const gauge20 = Number(gaugeCounts['2.0'] || 0);
          return { gauge16, gauge20, totalCount };
        }

        function recommendSleeve(profile) {
          const { gauge16, gauge20, totalCount } = profile;
          if (totalCount <= 2 && gauge16 === 2 && gauge20 === 0) {
            return sleeveOptions.find(option => option.id === 'round') || sleeveOptions[0];
          }
          const qualifiesSmall = (
            (gauge16 >= 3 && gauge16 <= 4 && gauge20 === 0) ||
            (gauge16 === 1 && gauge20 === 1) ||
            (gauge16 === 2 && gauge20 === 1)
          );
          if (qualifiesSmall) {
            return sleeveOptions.find(option => option.id === 'small') || sleeveOptions[1];
          }
          return sleeveOptions.find(option => option.id === 'medium') || sleeveOptions[sleeveOptions.length - 1];
        }

        function colorDisplayName(color) {
          const names = { black: '黒', blue: '青', red: '赤' };
          return names[color] || color;
        }

        function insertJunction(wire, segmentIndex, point) {
          recordHistory();
          const junction = createJunction(point);

          const originalPoints = wire.points.map(p => ({ x: p.x, y: p.y }));
          const headPoints = originalPoints.slice(0, segmentIndex + 1);
          const tailPoints = originalPoints.slice(segmentIndex + 1);
          const junctionPoint = { x: point.x, y: point.y };

          const originalEndConnectorId = wire.endConnectorId || null;
          const currentGauge = wire.gauge || conductorGaugeOptions[0].value;

          wire.points = [...headPoints, { x: junctionPoint.x, y: junctionPoint.y }];
          wire.endConnectorId = junction.id;
          wire.gauge = currentGauge;
          simplifyWirePoints(wire);

          if (originalEndConnectorId) {
            const tailColor = state.selectedColor !== wire.color ? state.selectedColor : wire.color;
            const tailGauge = state.selectedGauge !== currentGauge ? state.selectedGauge : currentGauge;
            state.counters.wire += 1;
            const newWire = {
              id: 'wire-' + state.counters.wire,
              color: tailColor,
              gauge: tailGauge,
              points: [{ x: junctionPoint.x, y: junctionPoint.y }, ...tailPoints.map(p => ({ x: p.x, y: p.y }))],
              startConnectorId: junction.id,
              endConnectorId: originalEndConnectorId
            };
            simplifyWirePoints(newWire);
            const wireIndex = state.wires.findIndex(item => item.id === wire.id);
            if (wireIndex >= 0) {
              state.wires.splice(wireIndex + 1, 0, newWire);
            } else {
              state.wires.push(newWire);
            }
          }

          return junction;
        }

        function syncWireEndpoints(wire) {
          if (wire.startConnectorId) {
            const startPos = getConnectorPositionById(wire.startConnectorId);
            if (startPos) {
              wire.points[0] = { x: startPos.x, y: startPos.y };
            }
          }
          if (wire.endConnectorId) {
            const endPos = getConnectorPositionById(wire.endConnectorId);
            if (endPos) {
              wire.points[wire.points.length - 1] = { x: endPos.x, y: endPos.y };
            }
          }
        }

        function findConnectorAt(point) {
          const radius = 12;
          for (const component of state.components) {
            for (const connector of component.connectors) {
              const position = getConnectorPositionById(connector.id);
              if (position && distance(point, position) <= radius) {
                return { id: connector.id, kind: 'component', component, connector, position };
              }
            }
          }
          for (const junction of state.junctions) {
            if (distance(point, junction) <= radius) {
              return { id: junction.id, kind: 'junction', junction, position: { x: junction.x, y: junction.y } };
            }
          }
          return null;
        }

        function findComponentAt(point) {
          for (let i = state.components.length - 1; i >= 0; i -= 1) {
            const component = state.components[i];
            const { position, size } = component;
            if (
              point.x >= position.x &&
              point.x <= position.x + size.width &&
              point.y >= position.y &&
              point.y <= position.y + size.height
            ) {
              return component;
            }
          }
          return null;
        }

        function findWireSegment(point) {
          let closest = null;
          state.wires.forEach(wire => {
            for (let i = 0; i < wire.points.length - 1; i += 1) {
              const start = wire.points[i];
              const end = wire.points[i + 1];
              const projection = projectPointToSegment(point, start, end);
              if (!projection) continue;
              const dist = distance(point, projection);
              if (!closest || dist < closest.distance) {
                closest = { wire, segmentIndex: i, distance: dist, projection };
              }
            }
          });
          return closest;
        }

        function getConnectorPositionById(id) {
          if (componentConnectorIndex.has(id)) {
            const { component, connector } = componentConnectorIndex.get(id);
            const center = getComponentCenter(component);
            const offset = getConnectorOffsetForComponent(component, connector);
            return { x: center.x + offset.x, y: center.y + offset.y };
          }
          if (state.junctionIndex.has(id)) {
            const junction = state.junctionIndex.get(id);
            return { x: junction.x, y: junction.y };
          }
          return null;
        }

        function getConductorStroke(color) {
          const palette = { black: '#111827', blue: '#1d4ed8', red: '#dc2626' };
          return palette[color] || color;
        }

        function distance(a, b) {
          return Math.hypot(a.x - b.x, a.y - b.y);
        }

        function projectPointToSegment(point, start, end) {
          const dx = end.x - start.x;
          const dy = end.y - start.y;
          const lenSq = dx * dx + dy * dy;
          if (lenSq === 0) return null;
          let t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / lenSq;
          t = Math.max(0, Math.min(1, t));
          return { x: start.x + t * dx, y: start.y + t * dy };
        }

        function getComponentCenter(component) {
          return {
            x: component.position.x + component.size.width / 2,
            y: component.position.y + component.size.height / 2
          };
        }

        function getConnectorOffsetForComponent(component, connector) {
          const baseSize = component.baseSize || component.size;
          const rotation = normalizeRotation(component.rotation || 0);
          const halfWidth = baseSize.width / 2;
          const halfHeight = baseSize.height / 2;
          const dx = connector.offset.x - halfWidth;
          const dy = connector.offset.y - halfHeight;
          switch (rotation) {
            case 0:
              return { x: dx, y: dy };
            case 90:
              return { x: -dy, y: dx };
            case 180:
              return { x: -dx, y: -dy };
            case 270:
              return { x: dy, y: -dx };
            default: {
              const radians = (rotation * Math.PI) / 180;
              return {
                x: dx * Math.cos(radians) - dy * Math.sin(radians),
                y: dx * Math.sin(radians) + dy * Math.cos(radians)
              };
            }
          }
        }

        function getRotatedSize(baseSize, rotation) {
          const normalized = normalizeRotation(rotation || 0);
          if (normalized % 180 === 0) {
            return { width: baseSize.width, height: baseSize.height };
          }
          return { width: baseSize.height, height: baseSize.width };
        }

        function normalizeRotation(value) {
          const normalized = value % 360;
          return normalized < 0 ? normalized + 360 : normalized;
        }

        function getCanvasPoint(evt) {
          const rect = canvas.getBoundingClientRect();
          return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }

        function debounce(fn, delay) {
          let timer = null;
          return (...args) => {
            window.clearTimeout(timer);
            timer = window.setTimeout(() => fn(...args), delay);
          };
        }

        init();
      })();
    </script>
  </body>
  </html>
